(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{491:function(t,v,_){"use strict";_.r(v);var s=_(14),a=Object(s.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"tcp-协议"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议"}},[t._v("#")]),t._v(" TCP 协议")]),t._v(" "),_("h2",{attrs:{id:"tcp-的定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-的定义"}},[t._v("#")]),t._v(" TCP 的定义")]),t._v(" "),_("p",[t._v("传输控制协议（TCP） 是 TCP/IP协议族中的一个传输层协议。TCP提供进程到进程、全双工的和面向连接的服务。")]),t._v(" "),_("p",[_("img",{attrs:{src:"/tcp.png",alt:""}})]),t._v(" "),_("h3",{attrs:{id:"tcp的特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp的特点"}},[t._v("#")]),t._v(" TCP的特点")]),t._v(" "),_("ul",[_("li",[t._v("面向流的协议")]),t._v(" "),_("li",[t._v("全双工通信"),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("全双工服务")]),t._v(" "),_("p",[t._v("数据可在同一时间双向流动。TCP的两个断点分别有自己的发送缓存和接收缓存，报文段可在两个方向运动。")])])]),t._v(" "),_("li",[t._v("面向连接的协议")])]),t._v(" "),_("h2",{attrs:{id:"tcp-报文段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文段"}},[t._v("#")]),t._v(" TCP 报文段")]),t._v(" "),_("p",[t._v("TCP的分组称为报文段（segment）。")]),t._v(" "),_("h3",{attrs:{id:"格式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#格式"}},[t._v("#")]),t._v(" 格式")]),t._v(" "),_("p",[t._v("TCP 协议首部最小长度是 20 字节，首部有一个长度可变的选项部分，最大 40 字节，所以 TCP 首部长度是 20-60 字节大小。具体如图：")]),t._v(" "),_("p",[_("img",{attrs:{src:"/tcp_01.jpg",alt:"首部格式"}})]),t._v(" "),_("p",[t._v("字段解释：")]),t._v(" "),_("ul",[_("li",[t._v("序号：TCP 传输的时候每一个字节都按顺序编号；协议中的序号是本报文段所发送数据第一个字节的序号。序号也用于建立和结束连接时候使用。")]),t._v(" "),_("li",[t._v("确认号： 期望接收的字节编号，如果接收的编号为x的字节，那么他就返回x+1为确认号。")]),t._v(" "),_("li",[t._v("窗口：可靠连接和流量控制中所用到的窗口大小。")]),t._v(" "),_("li",[t._v("紧急指针：只有当紧急标志置位时这个字段才有效，此时报文段中包含了紧急数据，紧急指针定义了一个数值，把这个数值加到序号上就得出报文段数据部分中最后一个紧急字节的编号。")]),t._v(" "),_("li",[t._v("选项")])]),t._v(" "),_("p",[t._v("控制字段：")]),t._v(" "),_("ul",[_("li",[t._v("URG(Urgent):紧急字段，可以让该报文不按报文顺序优先被处理。比如用户突然终止传输关闭连接。")]),t._v(" "),_("li",[t._v("ACK(Acknowledge):所有建立连接后传送的报文 ACK 必须为 1。")]),t._v(" "),_("li",[t._v("PSH(Push):发送方将该报文推送向前，可以不用等缓存填满先提交给应用程序。")]),t._v(" "),_("li",[t._v("RST(Reset):连接出现严重差错时候设为 1，重新建立连接。也可用于拒绝建立连接。")]),t._v(" "),_("li",[t._v("SYN(Synchronize):建立连接时候的同步标志。SYN=1 而 ACK=0 时表示建立连接请求。")]),t._v(" "),_("li",[t._v("FIN(Finish):终止连接时的标志位。")])]),t._v(" "),_("h2",{attrs:{id:"tcp-连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-连接"}},[t._v("#")]),t._v(" TCP 连接")]),t._v(" "),_("p",[t._v("TCP 是面向连接的协议，面向连接的传输层协议在源点和终点之间建立一条虚路径。同属于一个报文的所有报文段都沿着这条虚路径发送。为整个报文使用一条虚路径能够更容易的实施确认过程以及对损伤或丢失报文的重传。")]),t._v(" "),_("p",[t._v("在TCP中，面向连接的传输需要经过三个阶段："),_("code",[t._v("连接建立")]),t._v(" "),_("code",[t._v("数据传输")]),t._v(" "),_("code",[t._v("连接终止")])]),t._v(" "),_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),_("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/tcp-01.jpg",width:"500"}}),t._v(" "),_("p",[t._v("1、由客户端发送请求报文建立TCP连接，其中报文包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。"),_("br"),t._v(" "),_("code",[t._v("SYN = 1, seq = x (x为发送端随机生成的数值)")])]),t._v(" "),_("p",[t._v("2、由服务端回复客户端发送的请求报文，其中包含seq序列号，是由服务端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段是由客户端发送过来的序列号seq的基础上加1进行回复。是用来告诉客户端TCP连接验证成功了。"),_("br"),t._v(" "),_("code",[t._v("SYN = 1, ack = x+1, seq = y (y为回复端随机生成的数值)")])]),t._v(" "),_("p",[t._v("3、客户端收到服务端发送的建立TCP连接的请求后，会使自己的seq序列号加1表示，并且再次回复ACK验证请求，在服务端返回的 seq 上 加1 进行回复。"),_("br"),t._v(" "),_("code",[t._v("SYN = 1, ack = y+1, seq = x+1")])]),t._v(" "),_("h3",{attrs:{id:"四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),_("img",{staticStyle:{display:"block",margin:"0 auto"},attrs:{src:"/tcp-02.jpg",width:"400"}}),t._v(" "),_("p",[t._v("1、客户端发送断开TCP连接的请求报文，报文包含seq序列号，由发送端随机生成，并且将报文的FIN置为1，表示需要断开TCP连接。"),_("br"),t._v(" "),_("code",[t._v("FIN = 1, seq = x (x为客户端随机生成的)")])]),t._v(" "),_("p",[t._v("2、服务端收到请求后并回复客户端发起的TCP断开连接的请求报文，报文包含seq序列号，由服务端随机生成，而且会产生ACK字段，ACK字段数值是客户端发送的seq序列号基础上加1回复，告诉客户端断开请求验证成功。"),_("br"),t._v(" "),_("code",[t._v("ack = x+1, seq = y")])]),t._v(" "),_("p",[t._v("3、服务端回复完客户端的断开TCP连接的请求之后，不会立即断开TCP的连接，会先确保断开前，所有的数据是否传输完毕，确认传输完毕后，就会将FIN置为1，并生成seq序列号发送给客户端。"),_("br"),t._v(" "),_("code",[t._v("FIN = 1, seq = z, ack = x+1")])]),t._v(" "),_("p",[t._v("4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。"),_("br"),t._v(" "),_("code",[t._v("FIN = 1，ACK=z+1，seq=h，h为客户端随机生成")])]),t._v(" "),_("h2",{attrs:{id:"tcp-可靠传输原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-可靠传输原理"}},[t._v("#")]),t._v(" TCP 可靠传输原理")]),t._v(" "),_("h2",{attrs:{id:"tcp-流量控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-流量控制"}},[t._v("#")]),t._v(" TCP 流量控制")]),t._v(" "),_("h2",{attrs:{id:"tcp-拥塞控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制"}},[t._v("#")]),t._v(" TCP 拥塞控制")]),t._v(" "),_("p",[t._v("TPC要考虑到网络的拥塞状况，发送方允许发送的数据量不仅要要受接收方的控制（流量控制），而且还要由网络的拥塞状况（如果有的话）来决定。")]),t._v(" "),_("p",[t._v("TCP处理拥塞的一般策略是基于三个阶段：")]),t._v(" "),_("ul",[_("li",[t._v("慢开始")]),t._v(" "),_("li",[t._v("拥塞避免")]),t._v(" "),_("li",[t._v("拥塞检测")])]),t._v(" "),_("p",[t._v("再慢开始阶段发送方从非常慢的传输速率开始，但很快就把速率增大到一个门限值，")])])}),[],!1,null,null,null);v.default=a.exports}}]);