(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{507:function(t,a,s){"use strict";s.r(a);var n=s(14),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"html-每日一题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html-每日一题"}},[t._v("#")]),t._v(" HTML 每日一题")]),t._v(" "),s("h2",{attrs:{id:"_01-减少dom数量的方法以及大量dom的优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_01-减少dom数量的方法以及大量dom的优化"}},[t._v("#")]),t._v(" 01 减少DOM数量的方法以及大量DOM的优化")]),t._v(" "),s("details",{staticClass:"custom-block details"},[s("summary",[t._v("查看答案")]),t._v(" "),s("h3",{attrs:{id:"方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[t._v("#")]),t._v(" 方法")]),t._v(" "),s("ul",[s("li",[t._v("使用伪元素。")]),t._v(" "),s("li",[t._v("按需加载，减少不必要的渲染。")]),t._v(" "),s("li",[t._v("结构合理、语义化标签。")])]),t._v(" "),s("h3",{attrs:{id:"大量dom存在时如何优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#大量dom存在时如何优化"}},[t._v("#")]),t._v(" 大量DOM存在时如何优化")]),t._v(" "),s("h4",{attrs:{id:"缓存dom对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存dom对象"}},[t._v("#")]),t._v(" 缓存DOM对象")]),t._v(" "),s("p",[t._v("首先不管在什么场景下。操作DOM一般首先会去访问DOM。尤其是像循环遍历这种时间复杂度可能会比较高的操作。那么可以在循环之前就将主节点，不必循环的DOM节点先获取到，那么在循环里就可以直接引用，而不必去重新查询。")]),t._v(" "),s("div",{staticClass:"language-Javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[t._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" rootElement "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("querySelector")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'#app'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" childList "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rootElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("child"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("childList"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h4",{attrs:{id:"文档片段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#文档片段"}},[t._v("#")]),t._v(" 文档片段")]),t._v(" "),s("p",[t._v("利用 "),s("code",[t._v("document.createDocumentFragment()")]),t._v(" 方法创建文档碎片节点，创建的是一个虚拟的节点对象。 向这个节点添加DOM节点，修改DOM节点并不会影响到真实的DOM结构。")]),t._v(" "),s("p",[t._v("我们可以利这一点先将我们需要修改的DOM一并修改完，保存至文档碎片中，然后用文档碎片一次性替换真实的DOM节点，与虚拟DOM类似，同样达到了不频繁修改DOM而导致的重排跟重绘的过程。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" fragment "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" document"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("createDocumentFragment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("operationDomHandle")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("fragment")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 操作")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("operationDomHandle")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fragment"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//然后在替换")]),t._v("\nrootElem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceChild")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fragment"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("oldDom"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("这样只会触发一次回流，效率会得到很大的提升。如果需要对元素进行复杂的操作（删除、添加自节点），那么我们应当先将元素从页面中移除，然后再对其进行操作，或者将其复制一个"),s("code",[t._v("cloneNode()")]),t._v("，在内存中进行操作后在替换原来的节点。")]),t._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" clone "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" old"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("cloneNode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("operationDomHandle")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("clone"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nrootElement"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("replaceChild")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("clone"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" oldDom\n")])])]),s("h4",{attrs:{id:"用innerhtml-代替高频的appendchild"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用innerhtml-代替高频的appendchild"}},[t._v("#")]),t._v(" 用innerHTML 代替高频的appendChild")]),t._v(" "),s("h4",{attrs:{id:"最优layout方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最优layout方案"}},[t._v("#")]),t._v(" 最优layout方案")]),t._v(" "),s("p",[t._v("批量读，一次性写。先对一个不在Render Tree上的节点进行操作，再把这个节点添加回Render Tree。这样只会触发一次DOM操作。 使用requestAnimationFrame(), 把任何导致重绘的操作放入requestAnimationFrame中。")]),t._v(" "),s("h4",{attrs:{id:"虚拟dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),s("p",[t._v("js模拟DOM树并对DOM树操作的一种技术。virtual DOM是一种纯js对象（字符串对象），所以对他操作会高效。")]),t._v(" "),s("p",[t._v("利用virtual dom， 将DOM抽象为虚拟DOM，在DOM发生变化的时候先对虚拟DOM进行操作，通过DOM diff算法将虚拟DOM和原虚拟DOM的结构做对比，最终批量的去修改真实的DOM结构，尽可能的避免了频繁修改DOM而导致的频繁的重排和重绘。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);